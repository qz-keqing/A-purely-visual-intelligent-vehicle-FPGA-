/******************************************************************************
 *  Copyright (c) 2016, Xilinx, Inc.
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions are met:
 *
 *  1.  Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer.
 *
 *  2.  Redistributions in binary form must reproduce the above copyright 
 *      notice, this list of conditions and the following disclaimer in the 
 *      documentation and/or other materials provided with the distribution.
 *
 *  3.  Neither the name of the copyright holder nor the names of its 
 *      contributors may be used to endorse or promote products derived from 
 *      this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR 
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *****************************************************************************/
/******************************************************************************
 *
 *
 * @file arduino_grove_imu.c
 *
 * IOP code (MicroBlaze) for grove IMU 10DOF.
 * The grove IMU has to be connected to an arduino interface 
 * via a shield socket.
 * Grove IMU is read only, and has IIC interface.
 * Hardware version 1.1.
 * http://www.seeedstudio.com/wiki/Grove_-_IMU_10DOF
 *
 * <pre>
 * MODIFICATION HISTORY:
 *
 * Ver   Who  Date     Changes
 * ----- --- ------- -----------------------------------------------
 * 1.00a yrq 04/25/16 release
 * 1.00d yrq 07/26/16 separate pmod and arduino
 *
 * </pre>
 *
 *****************************************************************************/

#include "MPU9250.h"
#include "ICM20600.h"
#include "circular_buffer.h"
#include "timer.h"
#include "i2c.h"
#include <xparameters.h>
#include "xil_io.h"
#include "motor.h"
#include "servo.h"
#include "xio_switch.h"
#include "ultrasonic_ranger.h"
#include "encoder.h"
#include "XTmrCtr.h"
#include "Xintc.h"
#include "math.h"

typedef struct
{
	float target_servo_angle;
	int velocity;
	Servo *servo;
	Encoder *encoderL;
	Encoder *encoderR;
	Motor *motorL;
	Motor *motorR;
}ISR_param;

#define NUM_SAMPLES              100

// Mailbox commands
#define INIT				1
#define RESET 				3
#define SET_IIC_PINS			5
#define GET_ACCL_DATA 		7
#define GET_GYRO_DATA 		9
#define GET_COMPASS_DATA 	11
#define GET_ENCODER_DATA 	13
#define SET_ENCODER_DIR 	15
#define SET_MOTOR_PINS 		17
#define SET_MOTOR_DIR 		19
#define SET_VELOCITY  		21
#define SET_SERVO_ANGLE  	23
#define SET_SERVO_PIN 		25
#define GET_ULRANGER_DATA 	27
#define SET_MOTOR_MODE      29

static i2c device;

// Byte operations
int iic_readBytes(uint8_t devAddr, uint8_t regAddr,
                uint8_t length, uint8_t *data){
	i2c_write(device, devAddr, &regAddr, 1);
    i2c_read(device, devAddr, data, length);
    return length;
}

int iic_readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data){
    i2c_write(device, devAddr, &regAddr, 1);
    i2c_read(device, devAddr, data, 1);
    return 1;
}

void iic_writeBytes(uint8_t devAddr, uint8_t regAddr,
                uint8_t length, uint8_t *data){
    int i;
    int len_total = (int)length+1;
    uint8_t temp[len_total];
    temp[0] = regAddr;
    for (i=1;i<len_total;i++){
        temp[i]=data[i-1];
    }
    i2c_write(device, devAddr, temp, len_total);
}

void iic_writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data){
    uint8_t temp[2];
    temp[0] = regAddr;
    temp[1] = *data;
    i2c_write(device, devAddr, temp, 2);
}

// Bit operations
int8_t iic_readBits(uint8_t devAddr, uint8_t regAddr,
                    uint8_t bitStart, uint8_t width, uint8_t *data) {
    /*
     * 01101001 read byte
     * 76543210 bit numbers
     *    xxx   parameters: bitStart=4, width=3
     *    010   masked
     *   -> 010 shifted
     */
    uint8_t count, b;
    uint8_t mask;
    if ((count = iic_readBytes(devAddr, regAddr, 1, &b)) != 0) {
        mask = ((1 << width) - 1) << (bitStart - width + 1);
        b &= mask;
        b >>= (bitStart - width + 1);
        *data = b;
    }
    return count;
}
int8_t iic_readBit(uint8_t devAddr, uint8_t regAddr,
                   uint8_t bitStart, uint8_t *data) {
    return iic_readBits(devAddr, regAddr, bitStart, (uint8_t) 1, data);
}

void iic_writeBits(uint8_t devAddr, uint8_t regAddr,
                     uint8_t bitStart, uint8_t width, uint8_t *data) {
    /*
     * 010 value to write
     * 76543210 bit numbers
     *    xxx   parameters: bitStart=4, width=3
     * 00011100 mask byte
     * 10101111 original value (sample)
     * 10100011 original & ~mask
     * 10101011 masked | value
     */
    uint8_t b, temp;
    temp = *data;
    if (iic_readBytes(devAddr, regAddr, 1, &b) != 0) {
        uint8_t mask = ((1 << width) - 1) << (bitStart - width + 1);
        // shift data into correct position
        temp <<= (bitStart - width + 1);
        // zero all non-important bits in data
        temp &= mask;
        // zero all important bits in existing byte
        b &= ~(mask);
        // combine data with existing byte
        b |= temp;
        iic_writeByte(devAddr, regAddr, &b);
    }
}
void iic_writeBit(uint8_t devAddr, uint8_t regAddr,
                    uint8_t bitStart, uint8_t *data) {
    iic_writeBits(devAddr, regAddr, bitStart, (uint8_t) 1, data);
}

// MPU9250 driver functions
void icm20600_init()
{
	_addr=ICM20600_I2C_ADDR1;
	// configuration
	iic_writeByte(_addr, ICM20600_CONFIG, 0x00);
	    // disable fifo
	iic_writeByte(_addr, ICM20600_FIFO_EN, 0x00);

	    // set default power mode
	ICM20600_setPowerMode(ICM_6AXIS_LOW_POWER);

	    // gyro config
	ICM20600_setGyroScaleRange(RANGE_2K_DPS);
	ICM20600_setGyroOutputDataRate(GYRO_RATE_1K_BW_176);
	ICM20600_setGyroAverageSample(GYRO_AVERAGE_1);

	    // accel config
	ICM20600_setAccScaleRange(RANGE_16G);
	ICM20600_setAccOutputDataRate(ACC_RATE_1K_BW_420);
	ICM20600_setAccAverageSample(ACC_AVERAGE_4);
}


void ICM20600_setPowerMode(uint8_t mode) {
    uint8_t data_pwr1;
    uint8_t data_pwr2 = 0x00;
    uint8_t data_gyro_lp;
    iic_readByte(_addr, ICM20600_PWR_MGMT_1, _buffer);
    data_pwr1 = _buffer[0];
    data_pwr1 &= 0x8f;                  // 0b10001111
    iic_readByte(_addr, ICM20600_GYRO_LP_MODE_CFG, _buffer);
    data_gyro_lp = _buffer[0];
    // When set to ¡®1¡¯ low-power gyroscope mode is enabled. Default setting is 0
    data_gyro_lp &= 0x7f;               // 0b01111111
    switch (mode) {
        case ICM_SLEEP_MODE:
            data_pwr1 |= 0x40;          // set 0b01000000
            break;

        case ICM_STANDYBY_MODE:
            data_pwr1 |= 0x10;          // set 0b00010000
            data_pwr2 = 0x38;           // 0x00111000 disable acc
            break;

        case ICM_ACC_LOW_POWER:
            data_pwr1 |= 0x20;          // set bit5 0b00100000
            data_pwr2 = 0x07;           //0x00000111 disable gyro
            break;

        case ICM_ACC_LOW_NOISE:
            data_pwr1 |= 0x00;
            data_pwr2 = 0x07;           //0x00000111 disable gyro
            break;

        case ICM_GYRO_LOW_POWER:
            data_pwr1 |= 0x00;          // dont set bit5 0b00000000
            data_pwr2 = 0x38;           // 0x00111000 disable acc
            data_gyro_lp |= 0x80;
            break;

        case ICM_GYRO_LOW_NOISE:
            data_pwr1 |= 0x00;
            data_pwr2 = 0x38;           // 0x00111000 disable acc
            break;

        case ICM_6AXIS_LOW_POWER:
            data_pwr1 |= 0x00;          // dont set bit5 0b00100000
            data_gyro_lp |= 0x80;
            break;

        case ICM_6AXIS_LOW_NOISE:
            data_pwr1 |= 0x00;
            break;

        default:
            break;
    }
    iic_writeByte(_addr, ICM20600_PWR_MGMT_1, data_pwr1);
    iic_writeByte(_addr, ICM20600_PWR_MGMT_2, data_pwr2);
    iic_writeByte(_addr, ICM20600_GYRO_LP_MODE_CFG, data_gyro_lp);
}


// SAMPLE_RATE = 1KHz / (1 + div)
// work for low-power gyroscope and low-power accelerometer and low-noise accelerometer
void ICM20600_setSampleRateDivier(uint8_t div) {
	iic_writeByte(_addr, ICM20600_SMPLRT_DIV, div);
}


void ICM20600_setAccScaleRange(uint8_t range) {
    uint8_t data;
    iic_readByte(_addr, ICM20600_ACCEL_CONFIG, _buffer);
    data = _buffer[0];
    data &= 0xe7; // 0b 1110 0111

    switch (range) {
        case RANGE_2G:
            data |= 0x00;   // 0bxxx00xxx
            _acc_scale = 4000;
            break;

        case RANGE_4G:
            data |= 0x08;   // 0bxxx01xxx
            _acc_scale = 8000;
            break;

        case RANGE_8G:
            data |= 0x10;   // 0bxxx10xxx
            _acc_scale = 16000;
            break;

        case RANGE_16G:
            data |= 0x18;   // 0bxxx11xxx
            _acc_scale = 32000;
            break;

        default:
            break;
    }

    iic_writeByte(_addr, ICM20600_ACCEL_CONFIG, data);
}


// for low power mode only
void ICM20600_setAccAverageSample(uint8_t sample) {
    uint8_t data = 0;
    iic_readByte(_addr, ICM20600_ACCEL_CONFIG2, _buffer);
    data = _buffer[0];

    data &= 0xcf; // & 0b11001111
    switch (sample) {
        case ACC_AVERAGE_4:
            data |= 0x00; // 0bxx00xxxx
            break;

        case ACC_AVERAGE_8:
            data |= 0x10; // 0bxx01xxxx
            break;

        case ACC_AVERAGE_16:
            data |= 0x20; // 0bxx10xxxx
            break;

        case ACC_AVERAGE_32:
            data |= 0x30; // 0bxx11xxxx
            break;

        default:
            break;
    }

    iic_writeByte(_addr, ICM20600_ACCEL_CONFIG2, data);
}


void ICM20600_setAccOutputDataRate(uint8_t odr) {
    uint8_t data;
    iic_readByte(_addr, ICM20600_ACCEL_CONFIG2, _buffer);
    data = _buffer[0];
    data &= 0xf0;  // 0b11110000

    switch (odr) {
        case ACC_RATE_4K_BW_1046:
            data |= 0x08;
            break;

        case ACC_RATE_1K_BW_420:
            data |= 0x07;
            break;

        case ACC_RATE_1K_BW_218:
            data |= 0x01;
            break;

        case ACC_RATE_1K_BW_99:
            data |= 0x02;
            break;

        case ACC_RATE_1K_BW_44:
            data |= 0x03;
            break;

        case ACC_RATE_1K_BW_21:
            data |= 0x04;
            break;

        case ACC_RATE_1K_BW_10:
            data |= 0x05;
            break;

        case ACC_RATE_1K_BW_5:
            data |= 0x06;
            break;

        default:
            break;
    }

    iic_writeByte(_addr, ICM20600_ACCEL_CONFIG2, data);
}


void ICM20600_setGyroScaleRange(uint8_t range) {
    uint8_t data = 0;
    iic_readByte(_addr, ICM20600_GYRO_CONFIG, _buffer);
    data = _buffer[0];
    data &= 0xe7; // 0b11100111

    switch (range) {
        case RANGE_250_DPS:
            data |= 0x00;   // 0bxxx00xxx
            _gyro_scale = 500;
            break;

        case RANGE_500_DPS:
            data |= 0x08;   // 0bxxx00xxx
            _gyro_scale = 1000;
            break;

        case RANGE_1K_DPS:
            data |= 0x10;   // 0bxxx10xxx
            _gyro_scale = 2000;
            break;

        case RANGE_2K_DPS:
            data |= 0x18;   // 0bxxx11xxx
            _gyro_scale = 4000;
            break;

        default:
            break;
    }

    iic_writeByte(_addr, ICM20600_GYRO_CONFIG, data);
}


// for low power mode only
void ICM20600_setGyroAverageSample(uint8_t sample) {
    uint8_t data = 0;
    iic_readByte(_addr, ICM20600_GYRO_LP_MODE_CFG, _buffer);
    data = _buffer[0];

    data &= 0x8f;           // 0b10001111
    switch (sample) {
        case GYRO_AVERAGE_1:
            data |= 0x00; // 0bx000xxxx
            break;

        case GYRO_AVERAGE_2:
            data |= 0x10; // 0bx001xxxx
            break;

        case GYRO_AVERAGE_4:
            data |= 0x20; // 0bx010xxxx
            break;

        case GYRO_AVERAGE_8:
            data |= 0x30; // 0bx011xxxx
            break;

        case GYRO_AVERAGE_16:
            data |= 0x40; // 0bx100xxxx
            break;

        case GYRO_AVERAGE_32:
            data |= 0x50; // 0bx101xxxx
            break;

        case GYRO_AVERAGE_64:
            data |= 0x60;
            break;

        case GYRO_AVERAGE_128:
            data |= 0x70;
            break;


        default:
            break;
    }

    iic_writeByte(_addr, ICM20600_GYRO_LP_MODE_CFG, data);
}



void ICM20600_setGyroOutputDataRate(uint8_t odr) {
    uint8_t data;
    iic_readByte(_addr, ICM20600_CONFIG, _buffer);
    data = _buffer[0];
    data &= 0xf8;  // DLPF_CFG[2:0] 0b11111000

    switch (odr) {
        case GYRO_RATE_8K_BW_3281:
            data |= 0x07;
            break;
        case GYRO_RATE_8K_BW_250:
            data |= 0x00;
            break;
        case GYRO_RATE_1K_BW_176:
            data |= 0x01;
            break;
        case GYRO_RATE_1K_BW_92:
            data |= 0x02;
            break;
        case GYRO_RATE_1K_BW_41:
            data |= 0x03;
            break;
        case GYRO_RATE_1K_BW_20:
            data |= 0x04;
            break;
        case GYRO_RATE_1K_BW_10:
            data |= 0x05;
            break;
        case GYRO_RATE_1K_BW_5:
            data |= 0x06;
            break;
    }

    iic_writeByte(_addr, ICM20600_CONFIG, data);
}

void ICM20600_getAcceleration(int16_t* x, int16_t* y, int16_t* z) {
    *x = ICM20600_getAccelerationX();
    *y = ICM20600_getAccelerationY();
    *z = ICM20600_getAccelerationZ();
}

int16_t ICM20600_getAccelerationX(void) {
    int32_t raw_data = ICM20600_getRawAccelerationX();
    raw_data = (raw_data * _acc_scale) >> 16;
    return (int16_t)raw_data;
}
int16_t ICM20600_getAccelerationY(void) {
    int32_t raw_data = ICM20600_getRawAccelerationY();
    raw_data = (raw_data * _acc_scale) >> 16;
    return (int16_t)raw_data;
}
int16_t ICM20600_getAccelerationZ(void) {
    int32_t raw_data = ICM20600_getRawAccelerationZ();
    raw_data = (raw_data * _acc_scale) >> 16;
    return (int16_t)raw_data;
}

int16_t ICM20600_getRawAccelerationX(void) {
	iic_readBytes(_addr, ICM20600_ACCEL_XOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

int16_t ICM20600_getRawAccelerationY(void) {
	iic_readBytes(_addr, ICM20600_ACCEL_YOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

int16_t ICM20600_getRawAccelerationZ(void) {
	iic_readBytes(_addr, ICM20600_ACCEL_ZOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

void ICM20600_getGyroscope(int16_t* x, int16_t* y, int16_t* z) {
    *x = ICM20600_getGyroscopeX();
    *y = ICM20600_getGyroscopeY();
    *z = ICM20600_getGyroscopeZ();
}

int16_t ICM20600_getGyroscopeX(void) {
    int32_t raw_data = ICM20600_getRawGyroscopeX();
    raw_data = (raw_data * _gyro_scale) >> 16;
    return (int16_t)raw_data;
}

int16_t ICM20600_getGyroscopeY(void) {
    int32_t raw_data = ICM20600_getRawGyroscopeY();
    raw_data = (raw_data * _gyro_scale) >> 16;
    return (int16_t)raw_data;
}

int16_t ICM20600_getGyroscopeZ(void) {
    int32_t raw_data = ICM20600_getRawGyroscopeZ();
    raw_data = (raw_data * _gyro_scale) >> 16;
    return (int16_t)raw_data;
}

int16_t ICM20600_getRawGyroscopeX(void) {
	iic_readBytes(_addr, ICM20600_GYRO_XOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

int16_t ICM20600_getRawGyroscopeY(void) {
	iic_readBytes(_addr, ICM20600_GYRO_YOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

int16_t ICM20600_getRawGyroscopeZ(void) {
	iic_readBytes(_addr, ICM20600_GYRO_ZOUT_H, 2, _buffer);
    return ((int16_t)_buffer[0] << 8) + _buffer[1];
}

int16_t ICM20600_getTemperature(void) {
    uint16_t rawdata;
    iic_readBytes(_addr, ICM20600_TEMP_OUT_H, 2, _buffer);
    rawdata = (((uint16_t)_buffer[0]) << 8) + _buffer[1];
    return (int16_t)(rawdata / 327 + 25);
}

void ICM20600_reset() {
    uint8_t data;
    iic_readByte(_addr, ICM20600_USER_CTRL, _buffer);
    data = _buffer[0];
    data &= 0xfe;  // ICM20600_USER_CTRL[0] 0b11111110
    data |= ICM20600_RESET_BIT;
    iic_writeByte(_addr, ICM20600_USER_CTRL, data);
}


void interruptSetup(XIntc * InterruptController,XTmrCtr * TimerCounterInst,int TMRCTR_DEVICE_ID,int INTC_DEVICE_ID,int TMRCTR_INTERRUPT_ID,int TIMER_CNTR,void * ISR, void * param)
{
	XTmrCtr_Initialize(TimerCounterInst, TMRCTR_DEVICE_ID);

	XIntc_Initialize(InterruptController, INTC_DEVICE_ID);

	XIntc_Connect(InterruptController,TMRCTR_INTERRUPT_ID,(XInterruptHandler)XTmrCtr_InterruptHandler,TimerCounterInst);

	XIntc_Start(InterruptController, XIN_REAL_MODE);

	XIntc_Enable(InterruptController, TMRCTR_INTERRUPT_ID);

	Xil_ExceptionInit();

	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XIntc_InterruptHandler,InterruptController);

	Xil_ExceptionEnable();

	XTmrCtr_SetHandler(TimerCounterInst,ISR,param);

	XTmrCtr_SetOptions(TimerCounterInst, TIMER_CNTR,XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);

	XTmrCtr_SetResetValue(TimerCounterInst, TIMER_CNTR, XPAR_MICROBLAZE_CORE_CLOCK_FREQ_HZ / 100);

	XTmrCtr_Start(TimerCounterInst, TIMER_CNTR);
}
const float Velocity_KP = 0.6, Velocity_KD =  0.6,Encoder2pwm = 41.7;
int Incremental_PD (int Target,int Encoder)
{
	static float Bias,Pwm,Last_bias;
	Bias=Target - Encoder*Encoder2pwm;
	Pwm+=Velocity_KD*(Bias-Last_bias)+Velocity_KP*Bias;
	//Pwm+=Velocity_KP*Bias;
	if(Pwm>1000)Pwm=1000;
	if(Pwm<-1000)Pwm=-1000;
	Last_bias=Bias;
	return Pwm;
}
#define SERVO_VAL_MIN 0
#define SERVO_VAL_MAX 180
#define PWM_MIN 120
#define PWM_MAX 480
int map_servo(int value)
{
	int res;
	if(value<SERVO_VAL_MIN)value = SERVO_VAL_MIN;
	if(value>SERVO_VAL_MAX)value = SERVO_VAL_MAX;
	float scale = (float)(PWM_MAX - PWM_MIN)/(float)(SERVO_VAL_MAX - SERVO_VAL_MIN);
	res = value*scale + PWM_MIN;
	return res;
}
void timer_10ms_ISR(void * CallBackRef)
{
	ISR_param * param = (ISR_param *)CallBackRef;
	int Motor;
	int servo_val;
	int Velocity_Left = get_encoder_data(param->encoderL);
	if(param->target_servo_angle < -45)param->target_servo_angle = -45;
	if(param->target_servo_angle > 45)param->target_servo_angle = 45;
	servo_val = 95 + param->target_servo_angle;
	servo_val = map_servo(servo_val);
	Motor = Incremental_PD(param->velocity, Velocity_Left);
	set_servo_pwm( param->servo,servo_val);
	set_motor_pwm( param->motorL,Motor);
}
static Servo servo;
static Motor motor0,motor1;
static Encoder encoder0,encoder1;
static Ultrasonic_ranger ulranger;
static XIntc intc;
static XTmrCtr timer_10ms;
int main()
{
   ISR_param param;
   param.motorL = &motor0;
   param.motorR = &motor1;
   param.encoderL = &encoder0;
   param.encoderR = &encoder1;
   param.servo = &servo;
   int cmd;
   int16_t ax, ay, az;
   int16_t gx, gy, gz;
   int16_t mx, my, mz;
   int val,val1,val2,val3;
   interruptSetup(&intc,&timer_10ms,XPAR_TMRCTR_1_DEVICE_ID,XPAR_INTC_0_DEVICE_ID,XPAR_INTC_0_TMRCTR_1_VEC_ID,0,timer_10ms_ISR,&param);
   makeURInstance(&ulranger,XPAR_CAR_IOP_ARDUINO_AXI_ULTRASONIC_RANGER_0_S_AXI_BASEADDR);
   makeServoInstance(&servo,XPAR_CAR_IOP_ARDUINO_AXI_PWM_SERVO_S_AXI_BASEADDR);
   makeEncoderInstance(&encoder0,XPAR_CAR_IOP_ARDUINO_AXI_ENCODER_0_S_AXI_BASEADDR);
   makeEncoderInstance(&encoder1,XPAR_CAR_IOP_ARDUINO_AXI_ENCODER_1_S_AXI_BASEADDR);
   makeMotorInstance(&motor0,0);
   makeMotorInstance(&motor1,1);
   init_io_switch();
   set_motor_ctrl_mode(&motor0,SIMPLE);
   set_motor_ctrl_mode(&motor1,SIMPLE);
   // Initialization
   device = i2c_open_device(0);
   // Run application
   while(1){
     // wait and store valid command
      while((MAILBOX_CMD_ADDR & 0x01)==0);
      cmd = MAILBOX_CMD_ADDR;

      switch(cmd){
      	  case INIT:
      		  motor_init(&motor0);
      		  motor_init(&motor1);
      		  servo_init(&servo);
      		  encoder_init(&encoder0);
      		  encoder_init(&encoder1);
      		  //mpu_init();
      		  icm20600_init();
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case RESET:
      		  //mpu_reset();
      		  ICM20600_reset();
      		  param.target_servo_angle = 0;
      		  param.velocity = 0;
      		  motor_init(&motor0);
      		  motor_init(&motor1);
      		  servo_init(&servo);
      		  encoder_init(&encoder0);
      		  encoder_init(&encoder1);
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case SET_IIC_PINS:
      		  val = MAILBOX_DATA(0);
      		  val1 = MAILBOX_DATA(1);
      		  set_pin(val,SDA0);
      		  set_pin(val1,SCL0);
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case GET_ACCL_DATA:
      		  //mpu_getMotion9(&ax, &ay, &az, &gx, &gy, &gz, &mx, &my, &mz);
      		  ICM20600_getAcceleration(&ax, &ay, &az);
      		  MAILBOX_DATA(0) = (signed int)ax;
      		  MAILBOX_DATA(1) = (signed int)ay;
      		  MAILBOX_DATA(2) = (signed int)az;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;
            
      	  case GET_GYRO_DATA:
      		  //mpu_getMotion9(&ax, &ay, &az, &gx, &gy, &gz, &mx, &my, &mz);
      		  ICM20600_getGyroscope(&gx, &gy, &gz);
      		  MAILBOX_DATA(0) = (signed int)gx;
      		  MAILBOX_DATA(1) = (signed int)gy;
      		  MAILBOX_DATA(2) = (signed int)gz;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;
            
      	  case GET_COMPASS_DATA:
      		  //mpu_getMotion9(&ax, &ay, &az, &gx, &gy, &gz, &mx, &my, &mz);
      		  MAILBOX_DATA(0) = (signed int)mx;
      		  MAILBOX_DATA(1) = (signed int)my;
      		  MAILBOX_DATA(2) = (signed int)mz;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;
            
      	  case GET_ENCODER_DATA:
      		  val = get_encoder_data(&encoder0);
      		  val1 = get_encoder_data(&encoder1);
      		  MAILBOX_DATA(0) = val;
      		  MAILBOX_DATA(1) = val1;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;
            
      	  case SET_ENCODER_DIR:
      		  val = MAILBOX_DATA(0);
      		  val1 = MAILBOX_DATA(1);
      		  set_encoder_dir(&encoder0,val);
      		  set_encoder_dir(&encoder1,val1);
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case SET_MOTOR_PINS:
      		  val = MAILBOX_DATA(0);
      		  val1 = MAILBOX_DATA(1);
      	 	  val2 = MAILBOX_DATA(2);
      		  val3 = MAILBOX_DATA(3);
      		  set_motor_pins(&motor0,val,val1);
      		  set_motor_pins(&motor1,val2,val3);
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case SET_VELOCITY:
      		  val = MAILBOX_DATA(0);
      		  param.velocity = val;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case SET_MOTOR_DIR:
      		  val = MAILBOX_DATA(0);
      		  val1 = MAILBOX_DATA(1);
      		  set_motor_dir(&motor0, val);
      		  set_motor_dir(&motor1, val1);
      	      MAILBOX_CMD_ADDR = 0x0;
      	      break;

      	  case SET_SERVO_ANGLE:
      		  param.target_servo_angle = MAILBOX_DATA_FLOAT(0);
      	      MAILBOX_CMD_ADDR = 0x0;
      	      break;

      	  case SET_SERVO_PIN:
      		  val = MAILBOX_DATA(0);
      		  set_servo_pin(&servo, val);
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case GET_ULRANGER_DATA:
      		  val = get_ulranger_data(&ulranger);
      		  MAILBOX_DATA(0) = val;
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;

      	  case SET_MOTOR_MODE:
      		  val = MAILBOX_DATA(0);
      		  set_motor_ctrl_mode(&motor0,val);
      	      MAILBOX_CMD_ADDR = 0x0;
      	      break;

      	  default:
      		  MAILBOX_CMD_ADDR = 0x0;
      		  break;
      }
   }
   return 0;
}
